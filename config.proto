package config ;

message Contig {
    // number of half-bytes to seek into the genome file to get to the
    // start of the contig
    required uint32 offset = 1 ;
	
    // start of the contig in the original sequence, 0-based
    required uint32 range_start = 2 ;

    // one-past-the-end of the contig in original sequence, 0-based
    required uint32 range_end = 3 ; 
}

message Sequence {
    // sequence name (first word of header in FASTA file)
    required string name = 1 ;

    // description of sequence (rest of header in FASTA file)
    optional string description = 2 ;

    // contigs (stretches without many Ns)
    repeated Contig contig = 3 ;

    // taxonomic id, if known and different from enclosing genome
    optional uint32 taxid = 6 ;
}

message Genome {
    // internal handle for the genome (short name, only used to report
	// matches)
    required string name = 1 ;

    // description of the genome (most likely from command line)
    optional string description = 3 ;

    // sequences (typically one per chromosome)
    repeated Sequence sequence = 4 ;

    // total length in nucleotides, essentially the file size
    required uint32 total_size = 5 ;

    // taxonomic id, if known and applies to whole genome
    optional uint32 taxid = 6 ;

    // maximum number of contiguous Ns; more constitute a gap
    required uint32 maxn = 7 ;
}

message CompactIndex {
    // file name of the indexed genome
    required string genome_name = 2 ;

    // length of words (the k in k-mer)
    required uint32 wordsize = 3 ;

    // cutoff for overrepresented k-mers, if absent, all k-mers are
    // indexed
    optional uint32 cutoff = 4 ;

    // total number of indexed k-mers (nearly equal to genome size
    // in the absence of a cutoff)
    optional uint32 indexsize = 5 ;
}

message CompactIndexSpec {
    required string name = 2 ;
    optional uint32 cutoff = 4 ;

    // If the index has slices, declare them here.  The value of
    // SGE_TASK_ID % number_of_slices is the slice to use.  We start
    // counting at 0, naturally.  The number is spliced in for $$ in the
    // index name.  Leave undefined to turn this gross hack off.
    optional uint32 number_of_slices = 15 ;
}

// Configuration of mapper/aligner for a subset of sequences.  The idea
// is to use every policy that matches a given sequence, merging them in
// the order they appear in the configuration(s)
message Policy {
    // applies to sequences of this minimum length
    optional uint32 minlength = 1 ;

    // applies to sequences of this maximum length
    optional uint32 maxlength = 2 ;

    // use these indexes
    repeated CompactIndexSpec use_compact_index = 3 ;

    // don't bother aligning if there are too many seeds
    optional uint32 repeat_threshold = 4 ;

    // join seeds on diagonals no more distant than this
    optional uint32 max_diag_skew = 5 ;

    // join seeds no further apart than this
    optional uint32 max_gap = 6 ;

    // minimum total length of combined seeds to make an alignment
    optional uint32 min_seed_len = 7 ; 

    // distance cutoff scaled by 1000
    // (need to add an E-Value cutoff at some point)
    required uint32 max_penalty_per_nuc = 8 ;

    // pattern to match names against
    optional string name_pattern = 9 ;
}

message Aligner {
    // rate of transversions, basically defines the mismatch penalty
    required float rate_of_transversions = 1 ;

    // rate of transitions, defaults to tranversion rate
    optional float rate_of_transitions = 2 ;

    // probability of a gap appearing, efectively defines the gap-open-penalty
    // defaults to gap-extension-penalty to yield linear gap costs
    optional float gap_open_rate = 3 ;

    // probability of a gap extension
    required float gap_extension_rate = 4 ;

    // deamination rate, double stranded
    optional float rate_of_ds_deamination = 5 [default = 0.0] ;
    
    // deamination rate, single stranded
    optional float rate_of_ss_deamination = 6 [default = 0.0] ;

    // mean overhang length
    // at each end of a read we say there's half a chance that it has an
    // overhang in the right (detectable) direction, and if so, the length is
    // geometrically distributed with a suitable parameter
	// if left out, no overhangs are produced
    optional float mean_overhang_length = 7 ;
}


// Configuration messages are both read from a file to configure the program
// and written as a kind of header to the output to leave an audit trail.
message Config {
    // path to look for genome and index files (rolled into one, since both are
    // intrinsically coupled after all)
    repeated string genome_path = 2 ;
    
    // rules to select indices
    repeated Policy policy = 3 ;

    // aligner configuration
    // There can be only one kind of aligner in a run, if none is configured,
    // you get the trivial ("flat") alignment.
    optional Aligner aligner = 4 ;
}

// vim:expandtab:ts=4:sw=4:cindent
