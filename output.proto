import "config.proto" ;

package output ;

message Header {
    // program version string
    required string version = 1 ;

    // copy of the config block used in the run
    required .config.Config config = 2 ;

    // index of first processed input, if input is sliced
    // multiple starts are possible after merging multiple outputs
    repeated uint32 sge_slicing_index = 3 ;

    // number of slices if input is sliced
    optional uint32 sge_slicing_stride = 4 [ default=1 ] ;

    // copy of command line
    repeated string command_line = 5 ;

    // to ease tracking of problems: grid engine job id and task id, if
    // available
    optional uint32 sge_job_id = 6 ;
    optional uint32 sge_task_id = 7 ;

    // indicates whether an output file is sorted by read name
    // (needed to merge files?)
    optional bool is_sorted_by_name = 15 [default=false] ;

    // indicates whether an output file is sorted by genome coordinate
    // (that is genome name, then sequence name, then earliest matching
    // position; useful for consensus calling?)
    optional bool is_sorted_by_coordinate = 14 [default=false] ;
}

message Footer {
	optional uint32 exit_code = 1 ;
}

// Result hits... all very ad-hoc and ugly.  We need:
// - best hit globally
// - score of best hit globally with different species
// - score of best hit globally with different order

// - best hit to some genome (usually, but not always human or
//   human/chimp hybrid)
// - score of second best hit to said genome
// - score of best hit to said genome, but different chromosome
// - if best is on sex chromosomes, score of best hit on same genome
//   outside sex chromosomes

message Hit {
    // description of the hit: genome, sequence, start point, length
    // (negative length counts on the RC'd strand)
    required string genome = 1 ;
    required string sequence = 2 ;
    required uint32 start_pos = 3 ;
    required sint32 aln_length = 4 ;

    // the alignment itself as pair of strings
    // XXX: find more compact encoding
    required string ref = 32 ;
    required string qry = 33 ;
    optional string con = 34 ;

    // Score and E-value (because it's customary to have one)
    required sint32 score = 5 ;
    optional float evalue = 6 ;

    // taxids if known: most specific, species and order
    // An absent taxid means it's not known.
    optional int32 taxid = 16 ;
    optional int32 taxid_species = 17 ;
    optional int32 taxid_order = 18 ;
}

enum Reason {
    // ordinary alignment
    aligned = 0 ;

    // couldn't align because there was no seed at all
    no_seeds = 1 ;

    // decided not to align because there were too many seeds
    too_many_seeds = 2 ;

    // all alignments exceeded the e-value cutoff
    bad_alignment = 3 ;

    // no policy how to align, therefore no alignment
    no_policy = 4 ;
}

message Result {
    // sequence identifier, can be left out iff it is implicit, e.g.
    // from being contained in a database where the id is the key
    optional string seqid = 1 ;

    // optional description (taken e.g. from FASTA file)
    optional string description = 13 ;

    // the sequence itself, if so desired (ASCII encoding---do we want
    // something more compact?)
    optional string sequence = 2 ;

    // number of bases trimmed at 5' (at 3') end if trimming was done
    optional int32 trim_left = 11 [ default = 0 ] ;
    optional int32 trim_right = 12 [ default = 0 ] ;

    // Reason we arrived at this result
    optional Reason reason = 10 [ default = aligned ] ;

    // For statistical purposes
    optional uint32 num_raw_seeds = 16 ;
    optional uint32 num_grown_seeds = 17 ;
    optional uint32 num_clumps = 18 ;

    // Best hit globally, if any.  Difference in bit score to the next
    // best one with different species, with different order, iff such
    // hits exist.
    optional Hit best_hit = 3 ;
    optional sint32 diff_to_next_species = 4 ;
    optional sint32 diff_to_next_order = 5 ;

    // Best hit to some selected genome (probably human), if any.
    // Difference in bit score to next best hit, to next best on
    // different chromosome, to next on different class of chromosomes,
    // if they exist.  Classes for this purpose are sex chromosomes,
    // autosomes and organelles.
    optional Hit best_to_genome = 6 ;
    optional sint32 diff_to_next = 7 ;
    optional sint32 diff_to_next_chromosome = 8 ;
    optional sint32 diff_to_next_chromosome_class = 9 ;
}

// An output file is a magic number ("ANFO") folowed by an Output
// message.  We read and write it one field at a time, though.
message Output {
    required Header header = 1 ;
    repeated Result result = 2 ;
    required Footer footer = 3 ;
}

