import "config.proto" ;

option optimize_for = SPEED ;

package output ;

message Header {
    // program version string
    required string version = 1 ;

    // copy of the config block used in the run
    required .config.Config config = 2 ;

    // index of first processed input, if input is sliced
    // multiple starts are possible after merging multiple outputs
    repeated uint32 sge_slicing_index = 3 ;

    // number of slices if input is sliced
    optional uint32 sge_slicing_stride = 4 [ default=1 ] ;

    // copy of command line
    repeated string command_line = 5 ;

    // to ease tracking of problems: grid engine job id and task id, if
    // available
    optional uint32 sge_job_id = 6 ;
    optional uint32 sge_task_id = 7 ;

    // indicates whether an output file is sorted by read name
    // (needed to merge files?)
    optional bool is_sorted_by_name = 15 [default=false] ;

    // indicates whether an output file is sorted by genome coordinate
    // (that is genome name, then sequence name, then earliest matching
    // position; useful for consensus calling?)
    optional bool is_sorted_by_coordinate = 14 [default=false] ;
}

message Footer {
	required uint32 exit_code = 1 ;
}

// Result hits... all very ad-hoc and ugly.  We need:
// - best hit globally
// - score of best hit globally with different species
// - score of best hit globally with different order

// - best hit to some genome (usually, but not always human or
//   human/chimp hybrid)
// - score of second best hit to said genome
// - score of best hit to said genome, but different chromosome
// - if best is on sex chromosomes, score of best hit on same genome
//   outside sex chromosomes

message Hit {
    // file name of the genome (can be used to locate the reference
    // sequence)
    optional string genome_file = 1 ;

    // globally unique name of the genome (used when sorting hits be
    // coordinate, can be used to locate the reference sequence if
    // present; if absent, the sequence name should be globally unique)
    optional string genome_name = 8 ;

    // name of the subject sequence (== chromosome or similar)
    required string sequence = 2 ;

    // minimum position where any nucleotide aligns, zero-based
    // This is the position of the 5'-most base if on the forward
    // strand, the position of the 3'-most based if on the reverse strand
    required uint32 start_pos = 3 ;

    // length of alignment on reference sequence, negative if on the
    // reverse strand
    required sint32 aln_length = 4 ;

    // Score (this is actually a penalty)
    required sint32 score = 5 ;

    // E-value (because it's customary to have one)
    optional float evalue = 6 ;

    // alignment as (binary equivalent of) a CIGAR line
    // Bytes 1..127 encode matches of 1..127nt, 129..191 is an insert of
    // 1..63nt, 193..255 a deletion of 1..63nt.  A NUL byte is a marker
    // for the place where the alignment started, bytes 128 and 192 are
    // reserved.
    // This is now actually required, it's declared optional to support
    // old files.
    optional bytes cigar = 7 ;

    // taxids if known: most specific, species and order
    // An absent taxid means it's not known.
    optional int32 taxid = 16 ;
    optional int32 taxid_species = 17 ;
    optional int32 taxid_order = 18 ;

    // The alignment itself as pair of strings, along with a CLUSTAL
    // style "conservation" line.  This is not normally stored in a
    // file, it is generated from the CIGAR line; but it's cool to have
    // for human readable output.
    optional string ref = 32 ;
    optional string qry = 33 ;
    optional string con = 34 ;
}

enum Reason {
    // ordinary alignment
    aligned = 0 ;

    // couldn't align because there was no seed at all
    no_seeds = 1 ;

    // decided not to align because there were too many seeds
    too_many_seeds = 2 ;

    // all alignments exceeded the e-value cutoff
    bad_alignment = 3 ;

    // no policy how to align, therefore no alignment
    no_policy = 4 ;

	// only repetitive seeds
	repeats_only = 5 ;
}

message Read {
    required string seqid = 1 ;
    optional string description = 13 ;
    optional string sequence = 2 ;
    optional bytes quality = 14 ;
}

message Result {
    // sequence identifier, can be left out iff it is implicit, e.g.
    // from being contained in a database where the id is the key
    optional string seqid = 1 ;

    // optional description (taken e.g. from FASTA file)
    optional string description = 13 ;

    // quality scores (Phred scale, raw, without silly offsets)
    optional bytes quality = 14 ;

    // the sequence itself, if so desired (ASCII encoding---do we want
    // something more compact?)
    optional string sequence = 2 ;

    // number of bases trimmed at 5' (at 3') end if trimming was done
    optional uint32 trim_left = 11 ;
    optional uint32 trim_right = 12 ;

    // Reason we arrived at this result
    optional Reason reason = 10 [ default = aligned ] ;

    // Some statistics about the seeding process
    optional uint32 num_raw_seeds = 16 ;
    optional uint32 num_grown_seeds = 17 ;
    optional uint32 num_clumps = 18 ;
    optional uint32 num_useless = 22 ;

    // Some statistics about the alignment process
    optional uint32 open_nodes_after_alignment = 19 ;
    optional uint32 closed_nodes_after_alignment = 20 ;
    optional uint32 tracked_closed_nodes_after_alignment = 21 ;

    // Best hit globally, if any.  Difference in bit score to the next
    // best one with different species, with different order, iff such
    // hits exist.
    optional Hit best_hit = 3 ;
    optional sint32 diff_to_next_species = 4 ;
    optional sint32 diff_to_next_order = 5 ;

    // Best hit to some selected genome (probably human), if any.
    // Difference in bit score to next best hit, to next best on
    // different chromosome, to next on different class of chromosomes,
    // if they exist.  Classes for this purpose are sex chromosomes,
    // autosomes and organelles.
    optional Hit best_to_genome = 6 ;
    optional sint32 diff_to_next = 7 ;
    optional sint32 diff_to_next_chromosome = 8 ;
    optional sint32 diff_to_next_chromosome_class = 9 ;

    // if this result is the consensus of multiple reads, those reads
    // can go here
    repeated Read member = 23 ;
}

// An output file is a magic number ("ANFO") folowed by an Output
// message.  We read and write it one field at a time, though.
message Output {
    required Header header = 1 ;
    repeated Result result = 2 ;
    required Footer footer = 3 ;
}

