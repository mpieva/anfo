import "config.proto" ;

package output ;

message Header {
    // program version string
    required string version = 1 ;

    // copy of the config block used in the run
    required .config.Config config = 2 ;

    // index of first processed input, if input is sliced
    // multiple starts are possible after merging multiple outputs
    repeated uint32 sge_slicing_index = 3 ;

    // number of slices if input is sliced
    optional uint32 sge_slicing_stride = 4 [ default=1 ] ;

    // copy of command line
    repeated string command_line = 5 ;

    // to ease tracking of problems: grid engine job id and task id, if
    // available
    optional uint32 sge_job_id = 6 ;
    optional uint32 sge_task_id = 7 ;

    // indicates whether an output file is sorted by read name
    // (needed to merge files?)
    optional bool is_sorted_by_name = 15 [default=false] ;

    // indicates whether an output file is sorted by genome coordinate
    // (that is genome name, then sequence name, then earliest matching
    // position; useful for consensus calling?)
    optional bool is_sorted_by_coordinate = 14 [default=false] ;
}

message Footer {
	optional uint32 exit_code = 1 ;
}

// Result hits... all very ad-hoc and ugly.  We need:
// - best hit globally
// - score of best hit globally with different species
// - score of best hit globally with different order

// - best hit to some genome (usually, but not always human or
//   human/chimp hybrid)
// - score of second best hit to said genome
// - score of best hit to said genome, but different chromosome
// - if best is on sex chromosomes, score of best hit on same genome
//   outside sex chromosomes

message Hit {
    // description of the hit: genome, sequence, start point, length
    // (negative length counts on the RC'd strand)
    required string genome = 1 ;
    required string sequence = 2 ;
    required uint32 start_pos = 3 ;
    required sint32 aln_length = 4 ;

    // Score and E-value (because it's customary to have one)
    required sint32 score = 5 ;
    optional float evalue = 6 ;

    // alignment as (binary equivalent of) a CIGAR line
    // Bytes 1..127 encode matches of 1..127nt, 129..191 is an insert of
    // 1..63nt, 193..255 a deletion of 1..63nt.  A NUL byte is a marker
    // for the place where the alignment started, bytes 128 and 192 are
    // reserved.
	// This is now actually required, it's declared optional to support
	// old files.
    optional bytes cigar = 7 ;

    // taxids if known: most specific, species and order
    // An absent taxid means it's not known.
    optional int32 taxid = 16 ;
    optional int32 taxid_species = 17 ;
    optional int32 taxid_order = 18 ;

    // The alignment itself as pair of strings, along with a CLUSTAL
	// style "conservation" line.  This is not normally stored in a
	// file, it is generated from the CIGAR line; but it's cool to have
	// for human readable output.
    optional string ref = 32 ;
    optional string qry = 33 ;
    optional string con = 34 ;
}

enum Reason {
    // ordinary alignment
    aligned = 0 ;

    // couldn't align because there was no seed at all
    no_seeds = 1 ;

    // decided not to align because there were too many seeds
    too_many_seeds = 2 ;

    // all alignments exceeded the e-value cutoff
    bad_alignment = 3 ;

    // no policy how to align, therefore no alignment
    no_policy = 4 ;
}

// Quality scores for each of the possible bases (raw, Phred scale)
// Obviously this is strictly more powerful than the sequence and/or one
// quality score, 
message FourQuality {
    required bytes quality_a = 1 ;
    required bytes quality_c = 2 ;
    required bytes quality_g = 3 ;
    required bytes quality_t = 4 ;
} 

message Result {
    // sequence identifier, can be left out iff it is implicit, e.g.
    // from being contained in a database where the id is the key
    optional string seqid = 1 ;

    // optional description (taken e.g. from FASTA file)
    optional string description = 13 ;

    // quality scores (Phred scale, raw, without silly offsets)
    optional bytes quality = 14 ;
    // alternatively, detailed quality scores
    optional FourQuality four_quality = 15 ;

    // the sequence itself, if so desired (ASCII encoding---do we want
    // something more compact?)
    optional string sequence = 2 ;

    // number of bases trimmed at 5' (at 3') end if trimming was done
    optional int32 trim_left = 11 [ default = 0 ] ;
    optional int32 trim_right = 12 [ default = 0 ] ;

    // Reason we arrived at this result
    optional Reason reason = 10 [ default = aligned ] ;

    // For statistical purposes
    optional uint32 num_raw_seeds = 16 [ default = 0 ] ;
    optional uint32 num_grown_seeds = 17 [ default = 0 ] ;
    optional uint32 num_clumps = 18 [ default = 0 ] ;

    // Best hit globally, if any.  Difference in bit score to the next
    // best one with different species, with different order, iff such
    // hits exist.
    optional Hit best_hit = 3 ;
    optional sint32 diff_to_next_species = 4 ;
    optional sint32 diff_to_next_order = 5 ;

    // Best hit to some selected genome (probably human), if any.
    // Difference in bit score to next best hit, to next best on
    // different chromosome, to next on different class of chromosomes,
    // if they exist.  Classes for this purpose are sex chromosomes,
    // autosomes and organelles.
    optional Hit best_to_genome = 6 ;
    optional sint32 diff_to_next = 7 ;
    optional sint32 diff_to_next_chromosome = 8 ;
    optional sint32 diff_to_next_chromosome_class = 9 ;
}

// An output file is a magic number ("ANFO") folowed by an Output
// message.  We read and write it one field at a time, though.
message Output {
    required Header header = 1 ;
    repeated Result result = 2 ;
    required Footer footer = 3 ;
}

